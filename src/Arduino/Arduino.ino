#include "MaglevSwitch_Board.h"
#include <cstdint>
#include "pico/stdlib.h"
#include "hardware/adc.h"
#include "hardware/gpio.h"
#include "hardware/i2c.h"
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include "Adafruit_TinyUSB.h"
#include "hid/Adafruit_USBD_HID.h"
#include "BarGraph.h"

#define DISPLAY_DEBUG // Showing the debugging screen
#define TEST_MODE

// Display
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

i2c_inst_t *i2c = i2c1;
TwoWire myWire(i2c, 2, 3);
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &myWire, -1);

#define NUM_BARS 4
BarGraph graph(SCREEN_WIDTH, SCREEN_HEIGHT, NUM_BARS);

static const unsigned char LOGO[] PROGMEM = { // Logo img
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xef, 0xdf, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xbf, 0xff, 0xdf, 0xff, 0xff, 
  0xff, 0xcf, 0xcf, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xbd, 0xff, 0xff, 0xfd, 0xdf, 0xff, 0xff, 
  0xff, 0xcf, 0xc7, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfd, 0xdf, 0xff, 0xff, 
  0xff, 0xaf, 0xd7, 0xa1, 0x47, 0xf7, 0x0f, 0xee, 0xfd, 0xfe, 0xdd, 0x9b, 0x60, 0x50, 0xf8, 0xff, 
  0xff, 0xaf, 0xdb, 0x9e, 0x3b, 0xf7, 0xf7, 0xed, 0xfd, 0xfd, 0xdd, 0xbb, 0xbd, 0x9f, 0xf7, 0xff, 
  0xff, 0x6f, 0x5b, 0xbf, 0x7d, 0xf7, 0xf7, 0xed, 0xfd, 0xe3, 0x9d, 0xbb, 0xbd, 0xdf, 0xf7, 0xff, 
  0xff, 0x6f, 0x5d, 0xbf, 0x7d, 0xf7, 0xf7, 0xdd, 0xfe, 0xdf, 0x5b, 0xbd, 0xbd, 0xdf, 0xf7, 0xff, 
  0xff, 0xef, 0x5c, 0xbf, 0x7d, 0xf7, 0x07, 0xdc, 0xfe, 0xbf, 0x6b, 0xbd, 0xbd, 0xdf, 0xf7, 0xff, 
  0xff, 0xef, 0x5e, 0xbf, 0x7d, 0xf7, 0xf7, 0xdf, 0xfe, 0xbf, 0x6b, 0xbd, 0xbd, 0xdf, 0xf7, 0xff, 
  0xff, 0xef, 0xdf, 0x9e, 0x3b, 0xf7, 0xf7, 0x3f, 0xff, 0xde, 0x6b, 0xbd, 0xbd, 0xdf, 0xf7, 0xff, 
  0xff, 0xef, 0xdf, 0xa1, 0x47, 0x07, 0x0c, 0x3e, 0xff, 0xe1, 0xf7, 0xbe, 0x63, 0xd0, 0xf7, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0x1f, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0x07, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x07, 0x00, 0xc0, 0xff, 0x03, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x07, 0x00, 0xc0, 0xff, 0x03, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x07, 0x00, 0xc0, 0xff, 0x01, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x07, 0x00, 0xc0, 0xff, 0x01, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x07, 0x00, 0x80, 0xff, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x03, 0x00, 0x80, 0xff, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x03, 0x00, 0x80, 0x7f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x03, 0x00, 0x80, 0x7f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x03, 0x00, 0x80, 0x3f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x01, 0x00, 0x80, 0x3f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x81, 0x00, 0x80, 0x1f, 0x00, 0x00, 0x78, 0x00, 0xc0, 0xff, 0x00, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x81, 0x00, 0x80, 0x1f, 0x08, 0x00, 0xf8, 0x00, 0xc0, 0x7f, 0x80, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x81, 0x00, 0x80, 0x0f, 0x08, 0x00, 0xf8, 0x00, 0x80, 0x3f, 0xc0, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x81, 0x00, 0x80, 0x07, 0x0c, 0x00, 0xf8, 0x01, 0x80, 0x1f, 0xe0, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x80, 0x00, 0x80, 0x07, 0x04, 0x00, 0xfc, 0x01, 0x00, 0x0f, 0xf0, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xc0, 0x01, 0x80, 0x03, 0x06, 0x00, 0xfc, 0x03, 0x00, 0x07, 0xf8, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xc0, 0x01, 0x00, 0x03, 0x06, 0x00, 0xfc, 0x03, 0x00, 0x02, 0xfc, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xc0, 0x01, 0x00, 0x01, 0x07, 0x00, 0xfc, 0x07, 0x00, 0x00, 0xfe, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xc0, 0x01, 0x00, 0x81, 0x03, 0x00, 0xfc, 0x07, 0x00, 0x00, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x7f, 0xc0, 0x01, 0x00, 0x80, 0x03, 0x00, 0xfe, 0x0f, 0x00, 0x80, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x7f, 0xe0, 0x01, 0x00, 0xc0, 0x03, 0x00, 0xfe, 0x0f, 0x00, 0xc0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x7f, 0xe0, 0x01, 0x00, 0xc0, 0x03, 0x00, 0xfe, 0x1f, 0x00, 0xe0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x7f, 0xe0, 0x01, 0x00, 0xe0, 0x03, 0x00, 0xfe, 0x3f, 0x00, 0xf0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x3f, 0xe0, 0x01, 0x00, 0xe0, 0x01, 0x00, 0xfe, 0x3f, 0x00, 0xf0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x3f, 0xf0, 0x01, 0x00, 0xf0, 0x01, 0x00, 0xff, 0x7f, 0x00, 0xe0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x3f, 0xf0, 0x03, 0x00, 0xf0, 0x01, 0x00, 0xff, 0x3f, 0x00, 0xc0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x3f, 0xf0, 0x03, 0x00, 0xf8, 0x01, 0x00, 0xff, 0x1f, 0x00, 0xc0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x3f, 0xf0, 0x03, 0x00, 0xf8, 0x01, 0x00, 0xff, 0x0f, 0x00, 0x80, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x1f, 0xf0, 0x03, 0x00, 0xfc, 0x00, 0x80, 0xff, 0x07, 0x00, 0x80, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x1f, 0xf8, 0x03, 0x00, 0xfe, 0x00, 0x80, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x1f, 0xf8, 0x03, 0x00, 0xfe, 0x00, 0x80, 0xff, 0x01, 0x02, 0x00, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x1f, 0xf8, 0x03, 0x00, 0xff, 0x00, 0x80, 0xff, 0x00, 0x03, 0x00, 0xfe, 0xff, 0xff, 
  0xff, 0xff, 0x1f, 0xf8, 0x03, 0x00, 0x7f, 0x00, 0x80, 0x7f, 0x80, 0x07, 0x00, 0xfe, 0xff, 0xff, 
  0xff, 0xff, 0x0f, 0xfc, 0x03, 0x80, 0x7f, 0x00, 0xc0, 0x3f, 0xc0, 0x07, 0x00, 0xfc, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0xfc, 0x03, 0x80, 0x7f, 0x00, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0xfc, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0xfc, 0x07, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0xf8, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0xfc, 0x07, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0xf8, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0xfc, 0x07, 0xe0, 0x3f, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0xf0, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0xfe, 0x07, 0xf0, 0x7f, 0x00, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0xf0, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// USB HID
Adafruit_USBD_HID usb_hid;

uint8_t const desc_hid_report[] = {
  TUD_HID_REPORT_DESC_KEYBOARD()
};


// Rotary encoder
volatile uint64_t lastInterruptTimeUs = 0; 
static uint64_t debounceDelayUs = 1500; // Debounce delay time(us)
volatile EncoderConditions encoderConditions;
void encoderInterrupt(void); // Prototype


// Semaphoere
static semaphore_t semaphoere;


// Pin assignments
const uint8_t G_DIGITAL_PINS[] = {
  20, 19,   18,   17, 16, 15, 
  21, 22, /*26,*/ 24, 23, 
  5,  /*29, 28, 27,*/ 25, 
  6,  4,    1,    0, 
  7,  8,    9,    10, 11
};
const uint8_t G_ANALOG_PINS[] = {
  26, 
  29, 28, 27
};


// Keycodes
char G_SW_KEY_CODES_LAYER1[] = {
  HID_KEY_ESCAPE,       HID_KEY_1,  HID_KEY_2,        HID_KEY_3,        HID_KEY_4,    HID_KEY_5, 
  HID_KEY_TAB,          HID_KEY_Q,                    HID_KEY_E,        HID_KEY_R, 
  HID_KEY_CAPS_LOCK,                                                    HID_KEY_F, 
  HID_KEY_SHIFT_LEFT,   HID_KEY_Z,  HID_KEY_X,        HID_KEY_C, 
  HID_KEY_CONTROL_LEFT, FN,         HID_KEY_GUI_LEFT, HID_KEY_ALT_LEFT, HID_KEY_SPACE
};
char G_MLSW_KEY_CODES_LAYER1[] = {
  HID_KEY_W, 
  HID_KEY_A,  HID_KEY_S,  HID_KEY_D
};

// Keycodes for the Fn layer
char G_SW_KEY_CODES_LAYER2[] = {
  HID_KEY_ESCAPE,       HID_KEY_F1, HID_KEY_F2,       HID_KEY_F3,       HID_KEY_F4,   HID_KEY_F5, 
  HID_KEY_TAB,          HID_KEY_Q,                    HID_KEY_E,        HID_KEY_R, 
  HID_KEY_CAPS_LOCK,                                  HID_KEY_F, 
  HID_KEY_SHIFT_LEFT,   HID_KEY_Z,  HID_KEY_X,        HID_KEY_C, 
  HID_KEY_CONTROL_LEFT, FN,         HID_KEY_GUI_LEFT, HID_KEY_ALT_LEFT, HID_KEY_SPACE
};
char G_MLSW_KEY_CODES_LAYER2[] = {
  HID_KEY_W, 
  HID_KEY_A,  HID_KEY_S, HID_KEY_D
};


// MagLevSwitch Thresholds
float G_ACTUATION_DEPTH[] = {
  0.8, 
  0.8, 0.8, 0.8
};
float G_RELEASE_DEPTH[] = {
  0.2, 
  0.2, 0.2, 0.2
};


// Output char codes array
uint8_t outCodes[6] = {};

// Current oled state
int8_t G_OLEDSTATE = -1;


MaglevSwitchBoard board 
  = MaglevSwitchBoard(G_SW_KEY_CODES_LAYER1, G_SW_KEY_CODES_LAYER2, 
      G_MLSW_KEY_CODES_LAYER1, G_MLSW_KEY_CODES_LAYER2,  
      G_ACTUATION_DEPTH, G_RELEASE_DEPTH, outCodes);


void setup() {
  i2c_init(i2c, 400 * 1000);
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  showLogo();
  
  #if !defined(TEST_MODE)
  hid_init();
  #endif
  attachInterrupt(digitalPinToInterrupt(ENCODER_A), encoderInterrupt, RISING);

  sem_init(&semaphoere, 1, 1);
  multicore_launch_core1(pollingLoop);
}

void loop() {
  const uint32_t intervalMs = 50;
  uint32_t prevMs           = 0;
  uint32_t currentMs        = 0;

  uint8_t cnt         = 0;
  uint8_t codes[6]    = {0};

  uint16_t values[4]  = {0};
  float normalizedValue[4] = {0.0};

  bool pressed        = false;
  bool pressedPrev    = false;

  while(1){
    pressedPrev   = pressed;
    currentMs     = to_ms_since_boot(get_absolute_time());

    sem_acquire_blocking(&semaphoere);
    
    cnt = board.outCodesCnt();
    memcpy(&codes, &outCodes, 6);

    for(int i = 0; i < 4; i++){
      values[i] = board.currentMaglevValue(i);
    }

    if(currentMs - prevMs >= intervalMs){
      prevMs  = currentMs;
      pressed = board.encoderPressed();
    }

    sem_release(&semaphoere);

    #if !defined(TEST_MODE)
    hid_task(codes, cnt);
    #endif
    
    for(int i = 0; i < 4; i++){
      normalizedValue[i] = (float)(values[i] - MLSW_LOWER_LIMIT) / (float)MLSW_RANGE;
    }

    if(pressed & !pressedPrev){
      G_OLEDSTATE++;
      if(G_OLEDSTATE > 8){
        G_OLEDSTATE = -1;
      }
    }

    updateOled(codes, cnt, normalizedValue, encoderConditions.position, G_OLEDSTATE);
  }
}

void pollingLoop(void){
  const uint64_t intervalUs = 1000;
  static uint64_t startUs   = 0;
  
  while(1){
    if(to_us_since_boot(get_absolute_time()) - startUs < intervalUs){
      continue;
    }
    startUs += intervalUs;
    
    sem_acquire_blocking(&semaphoere);
    board.updateState();
    sem_release(&semaphoere);
  }
}


void updateOled(uint8_t codes[6], uint8_t cnt, float values[4], double position, int8_t oledState){
  static int8_t prevOledState = -1;

  if(oledState == -1){
    if(prevOledState != -1){
      showLogo();
    }
  }
  else{
    display.clearDisplay();

    #ifdef DISPLAY_DEBUG
    display.setTextSize(1);
    display.setTextColor(WHITE);
    display.setCursor(0, 10);
    display.println("MagLev Switch MX!");

    for(int i = 0; i < 4; i++){
      display.setCursor(0, (20 + 10 * i));
      display.println(values[i]);
    }
    
    for(int i = 0; i < 4; i++){
      display.setCursor(30, (20 + 10 * i));
      display.println(G_ACTUATION_DEPTH[i]);
    }
    
    for(int i = 0; i < 4; i++){
      display.setCursor(60, (20 + 10 * i));
      display.println(G_RELEASE_DEPTH[i]);
    }
    
    display.setCursor(100, 20);
    display.println(position);

    display.setCursor(100, 30);
    display.println(cnt);
    
    display.setCursor(100, 40);
    display.println(oledState);
    #else
    graph.cursor = oledState;
    for (int i = 0; i < NUM_BARS; ++i) {;
      graph.setBarValue(i,  values[i]);
      graph.setBarThresholds(i, G_RELEASE_DEPTH[i], G_ACTUATION_DEPTH[i]);
    }
    graph.draw(display);
    #endif
    display.display();
  }

  prevOledState = oledState;
}

void showLogo(void){
  display.clearDisplay();
  display.drawXBitmap(0, 0, LOGO, 128, 64, 1);
  display.display();
}

void encoderInterrupt(void){
  uint64_t currentTimeUs = to_us_since_boot(get_absolute_time());

  if(currentTimeUs - lastInterruptTimeUs >= debounceDelayUs){
    lastInterruptTimeUs = currentTimeUs;
    if(digitalRead(ENCODER_B) == HIGH){
        encoderConditions.pulseCount--;
        increaseThreshold(G_OLEDSTATE, false);
    }
    else{
        encoderConditions.pulseCount++;
        increaseThreshold(G_OLEDSTATE, true);
    }
    
    if(encoderConditions.pulseCount >= 24){
      encoderConditions.pulseCount = 0;
    }
    else if(encoderConditions.pulseCount < 0){
      encoderConditions.pulseCount = 23;
    }
    encoderConditions.position = (double)(encoderConditions.pulseCount) / 23.0;
  }
}

void increaseThreshold(uint8_t state, bool increasing){
  uint8_t index = (state - 1) >> 1;
  uint8_t offset = (state - 1) & 1;
  
  float incremental = 0;
  if(increasing){
    incremental = 0.05;
  }
  else{
    incremental = -0.05;
  }

  if(offset == 0) {
    float result = G_ACTUATION_DEPTH[index] + incremental;
    if(result < 1.0 && result >= G_RELEASE_DEPTH[index]){
      G_ACTUATION_DEPTH[index] = result;
    }
  }
  else{
    float result = G_RELEASE_DEPTH[index] + incremental;
    if(result <= G_ACTUATION_DEPTH[index] && result >= 0.05){
      G_RELEASE_DEPTH[index] = result;
    }
  }
}

void hid_init(){
  usb_hid.setBootProtocol(HID_ITF_PROTOCOL_KEYBOARD);
  usb_hid.setPollInterval(2);
  usb_hid.setReportDescriptor(desc_hid_report, sizeof(desc_hid_report));
  usb_hid.setStringDescriptor("TinyUSB Keyboard");
  usb_hid.begin();
  while( !TinyUSBDevice.mounted() ) delay(1);
}

void hid_task(uint8_t codes[6], uint8_t cnt){
  static bool keyPressedPreviously = false;
  if ( TinyUSBDevice.suspended() && cnt )
  {
    TinyUSBDevice.remoteWakeup();
  }

  if (!usb_hid.ready()) return;

  if (cnt)
  {
    uint8_t const report_id = 0;
    uint8_t const modifier  = 0;

    keyPressedPreviously = true;
    usb_hid.keyboardReport(report_id, modifier, codes);
  }else
  {
    if (keyPressedPreviously)
    {
      keyPressedPreviously = false;
      usb_hid.keyboardRelease(0);
    }
  }
}
