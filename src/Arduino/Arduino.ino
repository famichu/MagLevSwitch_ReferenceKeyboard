#include "MaglevSwitch_Board.h"
#include <cstdint>
#include "pico/stdlib.h"
#include "hardware/adc.h"
#include "hardware/gpio.h"
#include "hardware/i2c.h"
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include "Adafruit_TinyUSB.h"
#include "hid/Adafruit_USBD_HID.h"

#define DISPLAY_DEBUG // Showing the debugging screen

// Display
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

i2c_inst_t *i2c = i2c1;
TwoWire myWire(i2c, 2, 3);
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &myWire, -1);

static const unsigned char LOGO[] PROGMEM = { // Logo img
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xef, 0xdf, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xbf, 0xff, 0xdf, 0xff, 0xff, 
  0xff, 0xcf, 0xcf, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xbd, 0xff, 0xff, 0xfd, 0xdf, 0xff, 0xff, 
  0xff, 0xcf, 0xc7, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfd, 0xdf, 0xff, 0xff, 
  0xff, 0xaf, 0xd7, 0xa1, 0x47, 0xf7, 0x0f, 0xee, 0xfd, 0xfe, 0xdd, 0x9b, 0x60, 0x50, 0xf8, 0xff, 
  0xff, 0xaf, 0xdb, 0x9e, 0x3b, 0xf7, 0xf7, 0xed, 0xfd, 0xfd, 0xdd, 0xbb, 0xbd, 0x9f, 0xf7, 0xff, 
  0xff, 0x6f, 0x5b, 0xbf, 0x7d, 0xf7, 0xf7, 0xed, 0xfd, 0xe3, 0x9d, 0xbb, 0xbd, 0xdf, 0xf7, 0xff, 
  0xff, 0x6f, 0x5d, 0xbf, 0x7d, 0xf7, 0xf7, 0xdd, 0xfe, 0xdf, 0x5b, 0xbd, 0xbd, 0xdf, 0xf7, 0xff, 
  0xff, 0xef, 0x5c, 0xbf, 0x7d, 0xf7, 0x07, 0xdc, 0xfe, 0xbf, 0x6b, 0xbd, 0xbd, 0xdf, 0xf7, 0xff, 
  0xff, 0xef, 0x5e, 0xbf, 0x7d, 0xf7, 0xf7, 0xdf, 0xfe, 0xbf, 0x6b, 0xbd, 0xbd, 0xdf, 0xf7, 0xff, 
  0xff, 0xef, 0xdf, 0x9e, 0x3b, 0xf7, 0xf7, 0x3f, 0xff, 0xde, 0x6b, 0xbd, 0xbd, 0xdf, 0xf7, 0xff, 
  0xff, 0xef, 0xdf, 0xa1, 0x47, 0x07, 0x0c, 0x3e, 0xff, 0xe1, 0xf7, 0xbe, 0x63, 0xd0, 0xf7, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0x1f, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0x07, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x07, 0x00, 0xc0, 0xff, 0x03, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x07, 0x00, 0xc0, 0xff, 0x03, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x07, 0x00, 0xc0, 0xff, 0x01, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x07, 0x00, 0xc0, 0xff, 0x01, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x07, 0x00, 0x80, 0xff, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x03, 0x00, 0x80, 0xff, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x03, 0x00, 0x80, 0x7f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x03, 0x00, 0x80, 0x7f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x03, 0x00, 0x80, 0x3f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x01, 0x00, 0x80, 0x3f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x81, 0x00, 0x80, 0x1f, 0x00, 0x00, 0x78, 0x00, 0xc0, 0xff, 0x00, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x81, 0x00, 0x80, 0x1f, 0x08, 0x00, 0xf8, 0x00, 0xc0, 0x7f, 0x80, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x81, 0x00, 0x80, 0x0f, 0x08, 0x00, 0xf8, 0x00, 0x80, 0x3f, 0xc0, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x81, 0x00, 0x80, 0x07, 0x0c, 0x00, 0xf8, 0x01, 0x80, 0x1f, 0xe0, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x80, 0x00, 0x80, 0x07, 0x04, 0x00, 0xfc, 0x01, 0x00, 0x0f, 0xf0, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xc0, 0x01, 0x80, 0x03, 0x06, 0x00, 0xfc, 0x03, 0x00, 0x07, 0xf8, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xc0, 0x01, 0x00, 0x03, 0x06, 0x00, 0xfc, 0x03, 0x00, 0x02, 0xfc, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xc0, 0x01, 0x00, 0x01, 0x07, 0x00, 0xfc, 0x07, 0x00, 0x00, 0xfe, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xc0, 0x01, 0x00, 0x81, 0x03, 0x00, 0xfc, 0x07, 0x00, 0x00, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x7f, 0xc0, 0x01, 0x00, 0x80, 0x03, 0x00, 0xfe, 0x0f, 0x00, 0x80, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x7f, 0xe0, 0x01, 0x00, 0xc0, 0x03, 0x00, 0xfe, 0x0f, 0x00, 0xc0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x7f, 0xe0, 0x01, 0x00, 0xc0, 0x03, 0x00, 0xfe, 0x1f, 0x00, 0xe0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x7f, 0xe0, 0x01, 0x00, 0xe0, 0x03, 0x00, 0xfe, 0x3f, 0x00, 0xf0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x3f, 0xe0, 0x01, 0x00, 0xe0, 0x01, 0x00, 0xfe, 0x3f, 0x00, 0xf0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x3f, 0xf0, 0x01, 0x00, 0xf0, 0x01, 0x00, 0xff, 0x7f, 0x00, 0xe0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x3f, 0xf0, 0x03, 0x00, 0xf0, 0x01, 0x00, 0xff, 0x3f, 0x00, 0xc0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x3f, 0xf0, 0x03, 0x00, 0xf8, 0x01, 0x00, 0xff, 0x1f, 0x00, 0xc0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x3f, 0xf0, 0x03, 0x00, 0xf8, 0x01, 0x00, 0xff, 0x0f, 0x00, 0x80, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x1f, 0xf0, 0x03, 0x00, 0xfc, 0x00, 0x80, 0xff, 0x07, 0x00, 0x80, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x1f, 0xf8, 0x03, 0x00, 0xfe, 0x00, 0x80, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x1f, 0xf8, 0x03, 0x00, 0xfe, 0x00, 0x80, 0xff, 0x01, 0x02, 0x00, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x1f, 0xf8, 0x03, 0x00, 0xff, 0x00, 0x80, 0xff, 0x00, 0x03, 0x00, 0xfe, 0xff, 0xff, 
  0xff, 0xff, 0x1f, 0xf8, 0x03, 0x00, 0x7f, 0x00, 0x80, 0x7f, 0x80, 0x07, 0x00, 0xfe, 0xff, 0xff, 
  0xff, 0xff, 0x0f, 0xfc, 0x03, 0x80, 0x7f, 0x00, 0xc0, 0x3f, 0xc0, 0x07, 0x00, 0xfc, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0xfc, 0x03, 0x80, 0x7f, 0x00, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0xfc, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0xfc, 0x07, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0xf8, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0xfc, 0x07, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0xf8, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0xfc, 0x07, 0xe0, 0x3f, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0xf0, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0xfe, 0x07, 0xf0, 0x7f, 0x00, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0xf0, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};


// USB HID
Adafruit_USBD_HID usb_hid;

uint8_t const desc_hid_report[] = {
  TUD_HID_REPORT_DESC_KEYBOARD()
};


// Rotary encoder
volatile uint64_t lastInterruptTimeUs = 0; 
static uint64_t debounceDelayUs = 1500; // Debounce delay time(us)
volatile EncoderConditions encoderConditions;
void encoderInterrupt(void); // Prototype


// Semaphoere
static semaphore_t semaphoere;


// Pin assignments
const uint8_t G_DIGITAL_PINS[] = {
  20, 19,   18,   17, 16, 15, 
  21, 22, /*26,*/ 24, 23, 
  5,  /*29, 28, 27,*/ 25, 
  6,  4,    1,    0, 
  7,  8,    9,    10, 11
};
const uint8_t G_ANALOG_PINS[] = {
  26, 
  29, 28, 27
};


// Keycodes
char G_SW_KEY_CODES_LAYER1[] = {
  HID_KEY_ESCAPE,       HID_KEY_1,  HID_KEY_2,        HID_KEY_3,        HID_KEY_4,    HID_KEY_5, 
  HID_KEY_TAB,          HID_KEY_Q,                    HID_KEY_E,        HID_KEY_R, 
  HID_KEY_CAPS_LOCK,                                                    HID_KEY_F, 
  HID_KEY_SHIFT_LEFT,   HID_KEY_Z,  HID_KEY_X,        HID_KEY_C, 
  HID_KEY_CONTROL_LEFT, FN,         HID_KEY_GUI_LEFT, HID_KEY_ALT_LEFT, HID_KEY_SPACE
};
char G_MLSW_KEY_CODES_LAYER1[] = {
  HID_KEY_W, 
  HID_KEY_A,  HID_KEY_S,  HID_KEY_D
};

// Keycodes for the Fn layer
char G_SW_KEY_CODES_LAYER2[] = {
  HID_KEY_ESCAPE,       HID_KEY_F1, HID_KEY_F2,       HID_KEY_F3,       HID_KEY_F4,   HID_KEY_F5, 
  HID_KEY_TAB,          HID_KEY_Q,                    HID_KEY_E,        HID_KEY_R, 
  HID_KEY_CAPS_LOCK,                                  HID_KEY_F, 
  HID_KEY_SHIFT_LEFT,   HID_KEY_Z,  HID_KEY_X,        HID_KEY_C, 
  HID_KEY_CONTROL_LEFT, FN,         HID_KEY_GUI_LEFT, HID_KEY_ALT_LEFT, HID_KEY_SPACE
};
char G_MLSW_KEY_CODES_LAYER2[] = {
  HID_KEY_W, 
  HID_KEY_A,  HID_KEY_S, HID_KEY_D
};


// MagLevSwitch Thresholds
float G_ACTUATION_DEPTH[] = {
  0.5, 
  0.5, 0.5, 0.5
};
float G_RELEASE_DEPTH[] = {
  0.8, 
  0.8, 0.8, 0.8
};


// Output char codes array
uint8_t outCodes[6] = {};

MaglevSwitchBoard board 
  = MaglevSwitchBoard(G_SW_KEY_CODES_LAYER1, G_SW_KEY_CODES_LAYER2, 
      G_MLSW_KEY_CODES_LAYER1, G_MLSW_KEY_CODES_LAYER2,  
      G_ACTUATION_DEPTH, G_RELEASE_DEPTH, outCodes);


void setup() {
  i2c_init(i2c, 400 * 1000);
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  showLogo();
  
  hid_init();
  attachInterrupt(digitalPinToInterrupt(ENCODER_A), encoderInterrupt, RISING);

  sem_init(&semaphoere, 1, 1);
  multicore_launch_core1(pollingLoop);
}

void loop() {
  const uint32_t intervalMs = 50;
  uint32_t prevMs           = 0;
  uint32_t currentMs        = 0;

  uint8_t cnt         = 0;
  uint8_t codes[6]    = {0};
  uint16_t values[4]  = {0};
  bool pressed        = false;
  bool pressedPrev    = false;

  while(1){
    pressedPrev   = pressed;
    currentMs     = to_ms_since_boot(get_absolute_time());

    sem_acquire_blocking(&semaphoere);
    
    cnt = board.outCodesCnt();
    memcpy(&codes, &outCodes, 6);

    for(int i = 0; i < 4; i++){
      values[i] = board.currentMaglevValue(i);
    }

    if(currentMs - prevMs >= intervalMs){
      prevMs  = currentMs;
      pressed = board.encoderPressed();
    }

    sem_release(&semaphoere);

    hid_task(codes, cnt);
    

    if(pressed & !pressedPrev){
      updateOled(codes, cnt, values, encoderConditions.position, true);
    }
    else{
      updateOled(codes, cnt, values, encoderConditions.position, false);
    }
  }
}

void pollingLoop(void){
  const uint64_t intervalUs = 1000;
  static uint64_t startUs   = 0;
  
  while(1){
    if(to_us_since_boot(get_absolute_time()) - startUs < intervalUs){
      continue;
    }
    startUs += intervalUs;
    
    sem_acquire_blocking(&semaphoere);
    board.updateState();
    sem_release(&semaphoere);
  }
}


void updateOled(uint8_t codes[6], uint8_t cnt, uint16_t values[4], double position, bool encoderPressed){
  static bool oledIsEnable = false;

  if(encoderPressed){
    oledIsEnable = !oledIsEnable;
    if(!oledIsEnable){
      showLogo();
    }
  }

  if(oledIsEnable){
    display.clearDisplay();

    #ifdef DISPLAY_DEBUG
    display.setTextSize(1);
    display.setTextColor(WHITE);
    display.setCursor(0, 10);
    display.println("MagLev Switch MX!");

    for(int i = 0; i < 4; i++){
      display.setCursor(0, (20 + 10 * i));
      display.println(values[i]);
    }
    display.setCursor(80, 20);
    display.println(position);

    for(int i = 0; i < 6; i++){
      display.setCursor((40 + 10 * i), 40);
      display.println((char)codes[i]);
    }

    display.setCursor(40, 50);
    display.println(cnt);
    #endif
    
    display.display();
  }
}

void showLogo(void){
  display.clearDisplay();
  display.drawXBitmap(0, 0, LOGO, 128, 64, 1);
  display.display();
}

void encoderInterrupt(void){
  uint64_t currentTimeUs = to_us_since_boot(get_absolute_time());

  if(currentTimeUs - lastInterruptTimeUs >= debounceDelayUs){
    lastInterruptTimeUs = currentTimeUs;
    if(digitalRead(ENCODER_B) == HIGH){
        encoderConditions.pulseCount--;
    }
    else{
        encoderConditions.pulseCount++;
    }
    
    if(encoderConditions.pulseCount >= 24){
      encoderConditions.pulseCount = 0;
    }
    else if(encoderConditions.pulseCount < 0){
      encoderConditions.pulseCount = 23;
    }
    encoderConditions.position = (double)(encoderConditions.pulseCount) / 23.0;
  }
}

void hid_init(){
  usb_hid.setBootProtocol(HID_ITF_PROTOCOL_KEYBOARD);
  usb_hid.setPollInterval(2);
  usb_hid.setReportDescriptor(desc_hid_report, sizeof(desc_hid_report));
  usb_hid.setStringDescriptor("TinyUSB Keyboard");
  usb_hid.begin();
  while( !TinyUSBDevice.mounted() ) delay(1);
}

void hid_task(uint8_t codes[6], uint8_t cnt){
  static bool keyPressedPreviously = false;
  if ( TinyUSBDevice.suspended() && cnt )
  {
    TinyUSBDevice.remoteWakeup();
  }

  if (!usb_hid.ready()) return;

  if (cnt)
  {
    uint8_t const report_id = 0;
    uint8_t const modifier  = 0;

    keyPressedPreviously = true;
    usb_hid.keyboardReport(report_id, modifier, codes);
  }else
  {
    if (keyPressedPreviously)
    {
      keyPressedPreviously = false;
      usb_hid.keyboardRelease(0);
    }
  }
}
